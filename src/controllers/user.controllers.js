import { asyncHandler } from "../utils/asyncHandler.js";
import {ApiError} from "../utils/ApiError.js"
import { User } from "../models/user.model.js";
import {uploadOnCloudinary} from "../utils/cloudinary.js"
import { ApiResponse } from "../utils/ApiResponse.js";
import jwt from "jsonwebtoken"

// This component is for user functions like register, login, logout,etc.

// Generate access and refresh tokens. As it may take time we place it in async function which takes the userId as input ( _id - generated by mongo).
// Here we will find the user first using this id and then we will generate two tokens access and refresh. We will put the refresh token in the user.refreshToken here user is the variable used to store the tuple in the User model who has logined 
// Then save it by bypassing all validations like true required fields.
// return the tokens thats it
const generateAccessAndRefreshTokens = async(userId)=>{
  try{
    const user = await User.findById(userId);
    const accessToken = user.generateAccessToken()
    const refreshToken = user.generateRefreshToken()
    user.refreshToken = refreshToken
    await user.save({validateBeforeSave: false})

    return {accessToken, refreshToken};
  }
  catch(error)
  {
    throw new ApiError(500, "Something wrong while generating tokens")
  }
}
// This is registerUser which takes values
export const registerUser = asyncHandler(async (req,res)=>{
  // get user details from frontend
  //validations - not empty
  //user already exists
  //check for images, checks for avatar
  //upload to cloudinary
  //create user object - create entry in db
  //remove password and refresh token field from response
  // return res

  const {fullname, email, username, password} = req.body

  const requiredFields = { fullname, email, username, password };

  for (const [key, value] of Object.entries(requiredFields)) {
  if (!value || typeof value !== "string" || value.trim() === "") {
    throw new ApiError(400, `${key} is required`);
  }
}

const existedUser = await User.findOne({
  $or: [{email},{username}]
})
if(existedUser) throw new ApiError(409, "User with email or password already exist")

const avatarLocalPath = req.files?.avatar[0]?.path;

const coverImgLocalPath = req.files?.coverImage[0]?.path;
// console.log(req.files);
if(!avatarLocalPath)
{
  throw new ApiError(400, "Avatar is required");
}

const avatar = await uploadOnCloudinary(avatarLocalPath)
const coverImg = await uploadOnCloudinary(coverImgLocalPath)

if(!avatar)
{
  throw new ApiError(400, "Avatar is required");
}

const user = await User.create({
  fullname,
  avatar: avatar.url,
  coverImage: coverImg?.url || "",
  email,
  password,
  username: username.toLowerCase()
})
const createdUser = await User.findById(user._id).select(
  "-password -refreshToken"
)
if(!createdUser)
{
  throw new ApiError(500,"Something went wrong while registering user")
}

return res.status(201).json(
  new ApiResponse(200, createdUser,"User registered successfully")
)

})

// LoginUser it takes username or email, and password.
export const loginUser = asyncHandler(async(req,res)=>{
  /*
  req.body -> data
    Username or email
    Password
    password check
    access and refresh token
    send cookie
  */
console.log("BODY:", req.body);
console.log("HEADERS:", req.headers["content-type"]);

 const { email = "", username = "", password } = req.body;

  console.log("\n \n", email)
  console.log("\n \n")

  if (!username && !email) {
    throw new ApiError(400,"username or email required")
  }
  if(username || email)
  {
    const user = await User.findOne({
      $or: [{username}, {email}]
    })

    if(!user)
    {
      throw new ApiError(404,"User not found");
    }

    // call the isPasswordCorrect function from the model. This is because it is not a normal function in another js it is a function integrated with the schema so any tuple (user) can access this like a built in function without import
    const isvalid = await user.isPasswordCorrect(password);

    if(!isvalid) throw new ApiError(404,"Invalid user credentials")

    // Extract the tokens
    const {accessToken, refreshToken} = await generateAccessAndRefreshTokens(user._id)
    
    // extra just store the details of the user
    const loggedInUser = await User.findById(user._id).select("-password -refreshToken")

    // options
    const options = {
      httpOnly : true,
      secure: false
    }

    // return res of the login with cookies 
    return res
    .status(200)
    .cookie("accessToken",accessToken, options)
    .cookie("refreshToken",refreshToken, options)
    .json(
      new ApiResponse(
        200,
        {
          user: loggedInUser, accessToken, refreshToken
        },
        "User logged in Successfully"
      )
    )
  }
})

// clear the details mainly the refresh token and access token and make it undefined in the db
export const logoutUser = asyncHandler(async(req,res)=>{
  await User.findByIdAndUpdate(
    req.user._id,
    {
      $set: {
        refreshToken: undefined
      }
    },
    {
      new: true
    }
  )
  const options = {
      httpOnly : true,
      secure: false
  }
  return res
  .status(200)
  .clearCookie("accessToken",options)
  .clearCookie("refreshToken",options)
  .json(new ApiResponse(200,{}, "User logged Out"))

})


export const refreshAccessToken = asyncHandler(async(req,res)=>{
  const incomingrefreshToken = req.cookies.refreshToken || req.body.refreshToken 
  if(!incomingrefreshToken)
  {
    throw new ApiError(401,"unauthorized request")
  }

  try {
    const decodeToken = jwt.verify(
      incomingrefreshToken,
      process.env.REFRESH_TOKEN_SECRET
    )

    console.log(decodeToken);
  
    const user = await User.findById(decodeToken?._id)
    console.log("user:",user)
    if(!user)
    {
      throw new ApiError(401,"Invalid Refresh Token")
    }

    console.log(incomingrefreshToken)
    console.log("\n", user.refreshToken)
    
    if(incomingrefreshToken != user.refreshToken)
    {
      throw new ApiError(401,"Refresh Token is expired or used")
    }
  
    const options = {
      httpOnly : true,
      secure: true
    }
    console.log("\n \n Hi")
    const {accessToken, newRefreshToken} = await generateAccessAndRefreshTokens(user._id)
  
    return res
    .status(200)
    .cookie("accessToken", accessToken, options)
    .cookie("refreshToken", newRefreshToken, options)
    .json(
      new ApiResponse(200, {accessToken, refreshToken: newRefreshToken}, )
    )
  } catch (error) {
    throw new ApiError(401, error?.message || "Error for refresh token")
  }
})

export const changeCurrentUserPassword = asyncHandler(async(req,res)=>{
  const {oldPassword, newPassword} = req.body;

  const user = await User.findById(req.user._id)

  if(newPassword != oldPassword)
  {
    throw new ApiError(400,"New password and old password are same")
  }

  const isPasswordValid = await user.isPasswordCorrect(oldPassword)

  if(!isPasswordValid)
  {
    throw new ApiError(400,"Old password is incorrect")
  }

  user.password = newPassword;

  await user.save();

  return res
  .status(200)
  .json(new ApiResponse(200, {}, "Password changed successfully"))
})

export const getCurrentUserDetails = asyncHandler(async(req,res)=>{
  return res
  .status(200)
  .json(new ApiResponse(200, req.user, "Current user details fetched successfully"))
});

export const updateCurrentUserDetails = asyncHandler(async(req,res)=>{
  const updateData = req.body;
  const updatedUser = await User.findByIdAndUpdate(
    req.user._id,
    {
      $set: updateData
    },
    {
      new: true
    }
  ).select("-password -refreshToken");

  return res
  .status(200)
  .json(new ApiResponse(200, updatedUser, "User details updated successfully"))
}); 

export const uploadUserAvatar = asyncHandler(async(req,res)=>{
  const avatarLocalPath = req.file?.path;

  if(!avatarLocalPath)
  {
    throw new ApiError(400, "Avatar is required");
  }

  const avatar = await uploadOnCloudinary(avatarLocalPath)

  if(!avatar.url)
  {
    throw new ApiError(400, "Avatar is required");
  }
  const updatedUser = await User.findByIdAndUpdate(
    req.user._id,
    {
      $set: {
        avatar: avatar.url
      }
    },
    {
      new: true
    }
  ).select("-password -refreshToken");
  return res
  .status(200)
  .json(new ApiResponse(200, updatedUser, "User avatar updated successfully"))
})

export const uploadUserCoverImage = asyncHandler(async(req,res)=>{
  const coverImageLocalPath = req.file?.path;
  if(!coverImageLocalPath)
  {
    throw new ApiError(400, "Cover image is required");
  }
  const coverImage = await uploadOnCloudinary(coverImageLocalPath)
  if(!coverImage.url)
  {
    throw new ApiError(400, "Cover image is required");
  }
  const updatedUser = await User.findByIdAndUpdate(
    req.user._id,
    {
      $set: {
        coverImage: coverImage.url
      }
    },
    {
      new: true
    }
  ).select("-password -refreshToken");
  return res
  .status(200)
  .json(new ApiResponse(200, updatedUser, "User cover image updated successfully"))
});